# Kotlin

## 基础

### 基础语法

#### 类型声明

- 增强的类型推导

  类型推导是Kotlin在Java基础上增强的语言特性之一。

- 声明函数返回值类型

  Kotlin使用fun关键字定义一个函数。与声明变量一样，类型信息放在函数名的后面。

  如果没有声明返回值的类型，函数会默认被当作返回Unit类型。



##### 密封类

> 通过`sealed`关键字来修饰一个类为密封类，若要继承则需要将子类定义在同一个文件中，其他文件中的类将无法继承这个类。

密封类的使用场景是有限的。可以将它看作是一种功能更强大的枚举。

**Kotlin & Java的限制修饰符比较**

| 修饰符   | 含义                           | 与Java比较                    |
| -------- | ------------------------------ | ----------------------------- |
| open     | 允许被继承或重写               | 相当于Java类与方法的默认情况  |
| abstract | 抽象类或抽象方法               | 与Java一致                    |
| final    | 不允许被继承或重写（默认情况） | 与Java主动指定final的效果一致 |

**Kotlin & Java的可见性修饰符比较**

| 修饰符    | 含义                                                 | 与Java比较                                   |
| --------- | ---------------------------------------------------- | -------------------------------------------- |
| public    | Kotlin中默认修饰符，全局可见                         | 与Java中public效果相同                       |
| protected | 受保护修饰符，类及子类可见                           | 含义一致，但作用域除了类及子类外，包内也可见 |
| private   | 私有修饰符，类内修饰只有本类可见，类外修饰文件内可见 | 私有修饰类，只有类内可见                     |
| internal  | 模块内可见                                           | 无                                           |

### 解决多继承问题

#### 接口实现多继承

Kotlin中的接口和Java很相似，但它除了可以定义带默认实现的方法外，还可以声明抽象的属性。

super关键字，利用它可以指定继承哪个父接口的方法。

#### 内部类解决多继承问题

由于内部类可以继承一个与外部类无关的类，这就保证了内部类的独立性。

Kotlin声明内部类，必须在这个类前面加一个inner关键字。

在Java中，通过在内部类的语法上增加一个static关键字，把它变成嵌套类。在Kotlin中，则是相反的思路，默认是一个嵌套类，必须加上inner关键字才是一个内部类，也就是说可以把静态的内部类看成是嵌套类。

内部类和嵌套类的区别在于，内部类包含着对其外部类实例的引用，在内部类中可以使用外部类中的属性；而嵌套类不包含对其外部类实例的引用，所以它无法调用其外部类的属性。

#### 使用委托代替多继承

**委托**是Kotlin新引入的语法。只需要通过`by`关键字就可以实现委托的效果。`by lazy`语法其实就是利用委托实现的延迟初始化语法。

委托除了延迟属性这种内置行为外，还提供了一种可观察属性的行为。



### 数据类

#### 用data class创建数据类

`data class` **数据类**

#### copy、componentN 与 解构

copy主要作用是从已有的数据类对象中copy一个新的数据类对象。是一种**浅拷贝**的方式。除了基本数据类型的属性，其他属性还是会引用同一个对象。

componentN可以理解为类属性的值，其中N代表属性的顺序。

```java
String birdInfo = "20.0, 1, blue";
String[] temps = birdInfo.split(",");
double weight = Double.valueOf(temps[0]);
int age = Integer.valueOf(temps[1]);
String color = temps[2];
```

Kotlin提供了更优雅的做法：

```kotlin
val (weight, age, color) = birdInfo.split(",")
```

这样做的原理就是**解构**，通过编译器的约定实现解构。

Kotlin对数组的解构也有一定限制，在数组中默认最多允许赋值5个变量。



#### 数据类的约定和使用

如果要声明一个数据类，必须满足以下几个条件：

- 数据类必须拥有一个构造方法，该方法至少包含一个参数，一个没有数据的数据类是没有任何用处的；
- 与普通的类不用，数据类构造方法的参数强制使用var或者val声明；
- `data class`之前不能用abstract、open、sealed或者inner进行修饰；



### 伴生对象

Kotlin中引入了伴生对象的概念，利用`companion object`两个关键字创造的语法。

伴生对象意为伴随某个类的对象，它属于这个类所有，因此半生对象跟Java中static修饰效果性质一样，全局只有一个单例。需要声明在类的内部，在类被装载时会被初始化。

伴生对象的另一个作用，实现工厂方法模式。

#### object

object声明的内容可以看成没有构造方法的类，它会在系统或者类加载时进行初始化。



## 代数数据类型（ADT）和模式匹配

### 和类型 & 积类型

#### 和类型

类型安全的；是一种“OR”的关系。

##### 密封类 sealed

密封类会通过一个`sealed`修饰符将其创建的子类进行限制，该类的子类只能定义在父类或者与父类同一个文件内。当我们使用when表达式时，不用去考虑非法的情况，也就是可以省略else分支。

### 模式匹配

模式匹配中的模式其实就是表达式。

#### 处理嵌套表达式

模式匹配中的模式就是表达式，模式匹配要匹配的就是表达式。模式匹配的核心其实就是解构，也就是反向构造表达式。

