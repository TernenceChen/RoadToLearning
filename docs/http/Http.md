---
typora-copy-images-to: ..\..\image
---

![](https://github.com/TernenceChen/Learn-Notes/blob/master/image/tcp_ip.png)

超文本传输协议（HyperText Transfer Protocol）是一个用于传输超媒体文档（例如 HTML）的**应用层**协议

HTTP协议的特点：

- 灵活可扩展
- 可靠传输。基于 TCP/IP 的
- HTTP 协议是一个应用层的协议
- 请求 - 应答
- 无状态
- 明文

URI : 统一资源标识符。最常见的形式是URL

HTML：超文本标记语言

HTTP：超文本传输协议。用来传输超文本

URL：统一资源定位符 

标准格式：[协议类型]://[服务器地址]:[端口号]/[资源层级UNIX文件路径] [文件名]? [查询]#[片段ID]

![](https://github.com/TernenceChen/Learn-Notes/blob/master/image/url.png)



TCP 是面向连接、可靠的、有序的传输协议，因此会有失败重传和按序机制。

UDP：非面向连接、不可靠的数据流传输。UDP在传输数据报前不用在客户和服务器之间建立一个连接，且没有超时重发等机制。



| HTTP版本 | 特点                                                         |
| -------- | ------------------------------------------------------------ |
| HTTP/0.9 | **只允许GET**动作从服务器获取HTML文档，并在**响应请求之后立即关闭连接** |
| HTTP/1.0 | **增加了HEAD、POST等新方法**；**增加了响应状态码**，标记可能的错误原因；在请求中加入了HTTP协议版本号；**引入了HTTP Header（头部）概念**，即请求头与响应头；**引入了Content-Type**，使得传输的数据不再限于文本。 |
| HTTP/1.1 | **增加了 PUT、DELETE 等新的方法**；**增加了缓存管理和控制**；明确了连接管理即**keepalive**，允许持久连接；**支持 pipeline**，无需等待前面的请求响应，即可发送第二次请求；**允许响应数据分块（chunked）**，即响应的时候不标明Content-Length，客户端就无法断开连接，直到收到服务端的 EOF ，利于传输大文件；**强制要求 Host 头**。 |
| HTTP/2   | 基于SPDY协议（基于TCP的会话层协议），是**二进制协议**，不再是纯文本，减少了数据开销，降低了网络延迟，提升了吞吐量；支持**多路复用**，移除了pipeline，完全异步化；**利用HPACK压缩头部**，减少了数据传输量，减少了带宽使用；**允许服务端主动推送数据**。往性能优化的角度发展。 |
| HTTP/3   | 基于QUIC协议（**Q**uick **U**DP **I**nternet **C**onnections 快速UDP网络连接）， |



Http/1.1协议 pipeline 是将多个HTTP请求(request)整批提交的技术，而在发送过程中不需先等待服务器的回应。

对头阻塞（HOL blocking）可能会发生，造成延迟。

POST将不会被管线化，连续的 GET 和 HEAD 请求总可以管线化的。初次创建连接时，也不应使用流水线机制，因为对方不一定支持HTTP/1.1协议



**Q：** 在浏览器中输入URL到整个页面显示在用户面前时这个过程中到底发生了什么？

- URL输入

- DNS解析 DNS 域名服务器

- TCP连接

- 发送HTTP请求

- 服务器处理请求

- 服务器响应请求

- 浏览器解析渲染页面

- 连接结束

  ![](https://github.com/TernenceChen/Learn-Notes/blob/master/image/analysis.png)

![](https://github.com/TernenceChen/Learn-Notes/blob/master/image/visit.png)

**Q：**GET和POST的区别？

GET和POST最大的区别主要是GET请求是幂等性的，POST请求不是。

幂等性是指一次和多次请求某一个资源应该具有同样的副作用。

GET：获取资源，读取或下载数据；

​	搭配 URI 和其他头字段就能实现对资源更精细的操作

- 使用 If-Modified-Since 字段就变成了“有条件的请求”，仅当资源被修改时才会执行获取动作

- 使用 Range 字段就是“范围请求”，只获取资源的一部分数据。

POST：向资源提交数据，相当于写入或上传数据。





**Q：**断点续传

HTTP1.1协议中定义了断点续传相关的HTTP头 Range和Content-Range字段。



**请求方法**

GET：get方法一般用于获取服务器资源

POST：post方法一般用于传输实体主体

PUT：put方法一般用于传输文件

DELETE：delete方法用于删除文件

HEAD：head方法用于获取报文首部，不返回报文主体

OPTIONS：options方法用于询问请求URI资源支持的方法



**报文结构：**

![](https://github.com/TernenceChen/Learn-Notes/blob/master/image/newspaper.png)

- 起始行（start line）：描述请求或响应的基本信息；

- 头部字段集合（header）：使用 key-value 形式更详细地说明报文；

- 消息正文（entity）：实际传输的数据，它不一定是纯文本，可以是图片、视频等二进制数据。

**请求报文**是由请求行（请求方法、协议版本）、请求首部（请求URI、客户端信息等）和内容实体（用户信息和资源信息等，可为空）构成

![](https://github.com/TernenceChen/Learn-Notes/blob/master/image/request.png)

请求方法：GET/POST，表示对资源的操作

请求目标：通常是URI，标记了请求方法要操作的资源

版本号：HTTP协议版本



**响应报文**是由状态行（协议版本、状态码）、响应首部（服务器名称、资源标识等）和内容实体（服务端返回的资源信息）构成。

![](https://github.com/TernenceChen/Learn-Notes/blob/master/image/response.png)

版本号：表示报文使用的 HTTP 协议版本；

状态码：一个三位数，用代码的形式表示处理的结果，比如 200 是成功，500 是服务器错误；

原因/状态码描述：作为数字状态码补充，是更详细的解释文字，帮助人理解原因。



**状态码：**

- 1XX：信息性状态码 （接受的请求正在处理）

- 2XX：成功 （请求正常处理完毕）
  - 200：Ok，正常处理了
  - 204：No Content 已处理，无资源返回
  - 206：Partial Content 表示客户端进行了范围请求，而服务器成功执行了这部分的 GET 请求。响应报文中包含由 Content-Range指定范围的实体内容。比如断点续传。

- 3XX：重定向 （需要进行附加操作以完成请求）
  - 301 永久性重定向
  - 302 临时重定向
  - 303 表示资源存在着另一个 URL，客户端应当采用 GET 方法获取资源
  - 304 表示服务器允许访问资源，但请求未满足条件的情况（与重定向无关）
  - 307 临时重定向  期望客户端保持请求方法不变向新的地址发出请求
- 4XX：客户端错误 （服务器无法处理请求）
  - 400  请求报文中存在语法错误
  - 401  表示发送的请求需要有通过 HTTP 认证的认证信息
  - 403  禁止的，表示对请求资源的访问被服务器拒绝，可在实体主体部分返回原因描述
  - 404  表示在服务器上没有找到请求的资源

- 5XX：服务端错误 （服务器处理请求出错）
  - 500   服务器端在执行请求时发生了错误
  - 501   服务器不支持当前请求所需要的某个功能
  - 503   服务器暂时处于超负载或正在停机维护，无法处理请求



**首部字段**

**通用字段**： 请求头或响应头都可以出现

- **Date** 字段是一个通用字段，但通常出现在响应头里，表示 HTTP 报文创建的时间，客户端可以使用这个时间再搭配其他字段决定缓存策略。
- Cache-Control： 控制缓存的行为。控制缓存的行为：`no-cache`（强制向服务器再次验证）、`no-store`（不做任何缓存）、`max-age=111111`（资源可缓存最大时间 秒）、`public`（客户端、代理服务器都可利用缓存）、`private`（代理服务器不可用缓存）
- Connection：控制不再转发给代理的首部字段；**管理持久连接** Keep-Alive
- Via：为了追踪客户端与服务器之间的请求和响应报文 的传输路径。代理服务器相关信息，每经过一个代理服务器就会添加相关信息，用逗号分割。用于追踪报文的转发，还可避免请求回环的发生
- Pragma：只用于请求报文，客户端要求中间服务器不返回缓存的资源

**请求字段**： 仅可以出现在请求头中

- **Host** 字段，它属于请求字段，只能出现在请求头里，它同时也是唯一一个 HTTP/1.1 规范里要求必须出现的字段
- **User-Agent** 是请求字段，只出现在请求头里。它使用一个字符串来描述发起 HTTP 请求的客户端
- Accept：正确（优先级）接收的媒体类型
- Accept-Charset：正确（优先级）接收的字符集
- Accept-Encoding：正确（优先级）接收的内容编码
- Accept-Language：正确（优先级）接收的语言集
- If-Match：条件请求。服务器会比对 If-Match 的字段值和资源的 ETag 值，仅当两者一致时，才会执行请求。
- If-Modified-Since：比较时间。请求的资源 都没有过更新，则返回状态码 304 Not Modified 的响应
- If-None-Match：比较标记。本地资源未修改返回 304
- If-Range：与Range配合使用
- Range：只需获取部分资源的范围请求，包含首部字段Range即可告知服务器资源的指定范围。

**响应字段**： 仅能出现在响应头中

- **Server** 字段是响应字段，只能出现在响应头里。它告诉客户端当前正在提供 Web 服务的软件名称和版本号。
- Accept-Ranges：告知客户端服务器是否能处理范围请求。是`bytes`，否`none`
- ETag：资源标识，资源发生变化时标识也会发生改变
- Location：客户端重定向到某个 URL。配合3XX：提供重定向的URI。

**实体字段**：专门描述body的额外信息

- **Content-Length**是实体字段，它表示报文里 body 的长度，也就是请求头或响应头空行后面数据的长度。如果没有这个字段，那么 body 就是不定长的，需要使用 **chunked** 方式**分段传输**（仅在HTTP/1.1中提供）。
- Allow：用于通知客户端能够支持Request-URI指定资源的所有HTTP方法。GET、HEAD、POST
- Content-Range：响应主体的内容范围
- Expires：资源失效的日期。
- Last-Modified：资源最终修改的时间





### HTTP缓存

> HTTP 缓存机制就是，配置服务器响应头来告诉浏览器是否应该缓存资源、是否强制校验缓存、缓存多长时间；浏览器根据返回的响应头判断是否应该取缓存、缓存过期、发送请求头验证缓存是否可用、还是重新获取资源的过程。

#### HTTP缓存分类

> 根据是否需要重新向服务器发起请求来分类，可分为**强制缓存**和**协商缓存** 。根据是否可以被单个或者多个用户使用来分类，可分为私有缓存和共享缓存)。**强制缓存如果生效，不需要再和服务器发生交互，而协商缓存不管是否生效，都需要与服务端发生交互。**

##### 强制缓存

强制缓存在缓存数据未失效的情况下（即Cache-Control的max-age没有过期或者Expires的缓存时间没有过期），那么就会直接使用浏览器的缓存数据，不会再向服务器发送任何请求。强制缓存生效时，http状态码为200。这种方式页面的加载速度是最快的，性能也是很好的，但是在这期间，如果服务器端的资源修改了，页面上是拿不到的，因为它不会再向服务器发请求了。

跟强制缓存相关的header头属性有**Pragma**/**Cache-Control**（控制浏览器是否可以缓存资源、强制缓存校验、缓存时间）/**Expires**（与响应头中的Date对比）。

##### 协商缓存

当第一次请求时服务器返回的响应头中没有Cache-Control和Expires或者Cache-Control和Expires过期还或者它的属性设置为no-cache时(即不走强缓存)，那么浏览器第二次请求时就会与服务器进行协商，与服务器端对比判断资源是否进行了修改更新。么就会返回304状态码，告诉浏览器可以使用缓存中的数据，这样就减少了服务器的数据传输压力。如果数据有更新就会返回200状态码，服务器就会返回更新后的资源并且将缓存信息一起返回。

跟协商缓存相关的header头属性有**ETag**（强校验）/**If-Not-Match** 、**Last-Modified**（弱校验）/**If-Modified-Since**，请求头和响应头需要成对出现。



**http缓存都是从第二次请求开始的。**第一次请求资源时，服务器返回资源，并在respone header头中回传资源的缓存参数；第二次请求时，浏览器判断这些请求参数，命中强缓存就直接200，否则就把请求参数加到request header头中传给服务器，看是否命中协商缓存，命中则返回304，否则服务器会返回新的资源。

![](https://github.com/TernenceChen/Learn-Notes/blob/master/image/http_cache.png)

### HTTPS

> HTTPS = HTTP + SSL/TLS。SSL/TLS也应用在应用层（会话层）上，只不过是给HTTP套了一层安全的壳
>
> HTTPS基于HTTP协议，通过SSL或TLS提供加密处理数据、验证对方身份以及数据完整性保护。

特点：

- 内容加密：采用混合加密技术，中间者无法直接查看明文内容
- 验证身份：通过证书认证客户端访问的是自己的服务器
- 保护数据完整性：防止传输的内容被中间人冒充或篡改



服务端先用非对称加密的私钥key2加密对称加密的密钥key1，并传给客户端，客户端用非对称加密的公钥key3解密出对称加密的密钥key1，双方都有了密钥key1,开始利用key1加密通信。缺点：中间人可以自己生成非对称加密替换掉服务端公钥发送给客户端，此时客户端无法验证公钥的可信性。



SSL：首先需要从证书认证机构申请证书（证书中含有证书签名和服务端公钥`key3`）。在客户端发起HTTP请求时，服务端将证书发送给客户端。客户端认证证书的真伪，然后解密出服务端公钥`key3`，用公钥加密自己生成的对称加密密钥`key1`并传给服务端，最后利用`key1`加密进行通话。至于安全性，由于私钥是机构的，可以避免第三方伪造证书。并且就算得到了服务端公钥，也无法解密出公钥`key3`加密过的对称加密密钥`key1`。



HTTPS和HTTP的区别主要如下：

1. HTTPS协议需要到CA（证书颁发机构）申请证书，一般免费证书很少，需要交费。
2. HTTP协议运行在TCP之上，所有传输的内容都是明文，HTTPS运行在SSL/TLS之上，SSL/TLS运行在TCP之上，所有传输的内容都经过加密的。
3. HTTP和HTTPS使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。
4. http的连接很简单，是无状态的；HTTPS协议是由HTTP+SSL协议构建的可进行加密传输、身份认证的网络协议，可以有效的防止运营商劫持，解决了防劫持的一个大问题，比http协议安全。

![](https://github.com/TernenceChen/Learn-Notes/blob/master/image/https_http.png)

